<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Lucciefr: core/ringbuffer.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="powered-by-LuaJIT.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Lucciefr
   </div>
   <div id="projectbrief">Lua code caving, injection and exploration framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_4270bfced15e0e73154b13468c7c9ad9.html">core</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">ringbuffer.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Code to manage "ring" buffer logic.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="ringbuffer_8h_source.html">ringbuffer.h</a>&quot;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:acde44e8b3768111fba2f860354dde88a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ringbuffer_8c.html#acde44e8b3768111fba2f860354dde88a">ringbuffer_init</a> (<a class="el" href="structringbuffer__t.html">ringbuffer_t</a> *rb, size_t capacity, <a class="el" href="ringbuffer_8h.html#a1e23c366e2d91b26ccbd75c8494b82a8">free_func_t</a> free_func)</td></tr>
<tr class="memdesc:acde44e8b3768111fba2f860354dde88a"><td class="mdescLeft">&#160;</td><td class="mdescRight">"constructor", prepare a <a class="el" href="structringbuffer__t.html" title="Ring buffer structure. ">ringbuffer_t</a> before usage  <a href="#acde44e8b3768111fba2f860354dde88a">More...</a><br /></td></tr>
<tr class="separator:acde44e8b3768111fba2f860354dde88a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea28466854133fe19940d5c59b9c1feb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea28466854133fe19940d5c59b9c1feb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ringbuffer_8c.html#aea28466854133fe19940d5c59b9c1feb">ringbuffer_done</a> (<a class="el" href="structringbuffer__t.html">ringbuffer_t</a> *rb)</td></tr>
<tr class="memdesc:aea28466854133fe19940d5c59b9c1feb"><td class="mdescLeft">&#160;</td><td class="mdescRight">"destructor", free up a <a class="el" href="structringbuffer__t.html" title="Ring buffer structure. ">ringbuffer_t</a>'s resources after you're done <br /></td></tr>
<tr class="separator:aea28466854133fe19940d5c59b9c1feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb86c8b8d2f549a92ea89ed1d2d7dab1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afb86c8b8d2f549a92ea89ed1d2d7dab1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ringbuffer_8c.html#afb86c8b8d2f549a92ea89ed1d2d7dab1">ringbuffer_push</a> (<a class="el" href="structringbuffer__t.html">ringbuffer_t</a> *rb, void *element)</td></tr>
<tr class="memdesc:afb86c8b8d2f549a92ea89ed1d2d7dab1"><td class="mdescLeft">&#160;</td><td class="mdescRight">push an element pointer to the ring buffer (new "head" entry) <br /></td></tr>
<tr class="separator:afb86c8b8d2f549a92ea89ed1d2d7dab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3a76d299009734662111e96abbd5e8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ringbuffer_8c.html#af3a76d299009734662111e96abbd5e8b">ringbuffer_pop</a> (<a class="el" href="structringbuffer__t.html">ringbuffer_t</a> *rb)</td></tr>
<tr class="memdesc:af3a76d299009734662111e96abbd5e8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">discard the oldest entry ("tail" element) from the buffer.  <a href="#af3a76d299009734662111e96abbd5e8b">More...</a><br /></td></tr>
<tr class="separator:af3a76d299009734662111e96abbd5e8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b2bbb710932f95c9de104134eef52b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a10b2bbb710932f95c9de104134eef52b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ringbuffer_8c.html#a10b2bbb710932f95c9de104134eef52b">ringbuffer_clear</a> (<a class="el" href="structringbuffer__t.html">ringbuffer_t</a> *rb)</td></tr>
<tr class="memdesc:a10b2bbb710932f95c9de104134eef52b"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove (pop) all entries from the buffer, until it's empty again (count == 0) <br /></td></tr>
<tr class="separator:a10b2bbb710932f95c9de104134eef52b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35f9a507905ad794d320040437ccca25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ringbuffer_8c.html#a35f9a507905ad794d320040437ccca25">ringbuffer_resize</a> (<a class="el" href="structringbuffer__t.html">ringbuffer_t</a> *rb, size_t new_capacity)</td></tr>
<tr class="memdesc:a35f9a507905ad794d320040437ccca25"><td class="mdescLeft">&#160;</td><td class="mdescRight">resize the ring buffer (assign a new capacity).  <a href="#a35f9a507905ad794d320040437ccca25">More...</a><br /></td></tr>
<tr class="separator:a35f9a507905ad794d320040437ccca25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d601184cd06125df9846aa6f04911d8"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ringbuffer_8c.html#a4d601184cd06125df9846aa6f04911d8">ringbuffer_element</a> (<a class="el" href="structringbuffer__t.html">ringbuffer_t</a> *rb, size_t index)</td></tr>
<tr class="memdesc:a4d601184cd06125df9846aa6f04911d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the n-th entry (element pointer) from the ring buffer.  <a href="#a4d601184cd06125df9846aa6f04911d8">More...</a><br /></td></tr>
<tr class="separator:a4d601184cd06125df9846aa6f04911d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2687156335f978347ee27c76af75ce12"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ringbuffer_8c.html#a2687156335f978347ee27c76af75ce12">ringbuffer_tail</a> (<a class="el" href="structringbuffer__t.html">ringbuffer_t</a> *rb)</td></tr>
<tr class="memdesc:a2687156335f978347ee27c76af75ce12"><td class="mdescLeft">&#160;</td><td class="mdescRight">shortcut to retrieve "tail" element  <a href="#a2687156335f978347ee27c76af75ce12">More...</a><br /></td></tr>
<tr class="separator:a2687156335f978347ee27c76af75ce12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38ac5101fcc9e8f1f605966497c47965"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a38ac5101fcc9e8f1f605966497c47965"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ringbuffer_8c.html#a38ac5101fcc9e8f1f605966497c47965">ringbuffer_head</a> (<a class="el" href="structringbuffer__t.html">ringbuffer_t</a> *rb)</td></tr>
<tr class="memdesc:a38ac5101fcc9e8f1f605966497c47965"><td class="mdescLeft">&#160;</td><td class="mdescRight">shortcut to retrieve "head" element <br /></td></tr>
<tr class="separator:a38ac5101fcc9e8f1f605966497c47965"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Code to manage "ring" buffer logic. </p>
<p>A ring buffer is a 'cyclic' list of pointers that will normally be used as a "queue" / FIFO stack (first in, first out).</p>
<p>We're assuming that all elements in the list have been allocated in a uniform way, and that it may be necessary to call a specific "free" function before discarding them (to release any associated memory). E.g. for elements allocated via stdlib <code>malloc</code> or <code>calloc</code>, the corresponding function would of course be <code>free</code>.</p>
<p>Removing elements from the list happens on two occasions: either with a regular "pop", or in case you try to "push" a new element to a ring buffer that is currently full. (The latter will overwrite the oldest entry to make room for the new one.)</p>
<p>With "tail" we refer to the oldest element currently in the buffer (the one that was pushed earliest), and "head" means the most recent one (the 'top' element pushed last). The ring buffer keeps track of the number of elements and their associated pointers, as long as the element count doesn't exceed the capacity (maximum count = "size" of the buffer). As mentioned above, pushing a new element to a buffer that's full will overwrite the current "tail" (i.e. drop the oldest entry). </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a4d601184cd06125df9846aa6f04911d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* ringbuffer_element </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structringbuffer__t.html">ringbuffer_t</a> *&#160;</td>
          <td class="paramname"><em>rb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the n-th entry (element pointer) from the ring buffer. </p>
<p>Any invalid index will result in a <code>NULL</code> return value. Specifically, with an empty buffer you'll always get back <code>NULL</code> (for any value of index).</p>
<dl class="section note"><dt>Note</dt><dd>Here the <code>index</code> parameter is <em>relative to the current buffer position</em> - meaning <code>ringbuffer_element(rb, 0)</code> will always refer to the "tail", and <code>ringbuffer_element(rb, count - 1)</code> is the "head" entry. </dd></dl>

</div>
</div>
<a class="anchor" id="acde44e8b3768111fba2f860354dde88a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ringbuffer_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structringbuffer__t.html">ringbuffer_t</a> *&#160;</td>
          <td class="paramname"><em>rb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ringbuffer_8h.html#a1e23c366e2d91b26ccbd75c8494b82a8">free_func_t</a>&#160;</td>
          <td class="paramname"><em>free_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>"constructor", prepare a <a class="el" href="structringbuffer__t.html" title="Ring buffer structure. ">ringbuffer_t</a> before usage </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rb</td><td>the ring buffer to use </td></tr>
    <tr><td class="paramname">capacity</td><td>maximum number of elements (pointers) the buffer can hold </td></tr>
    <tr><td class="paramname">free_func</td><td>free function to use on an element before discarding it. optional, may be <code>NULL</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af3a76d299009734662111e96abbd5e8b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ringbuffer_pop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structringbuffer__t.html">ringbuffer_t</a> *&#160;</td>
          <td class="paramname"><em>rb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>discard the oldest entry ("tail" element) from the buffer. </p>
<p>This decrements count (i.e. frees up one 'slot'), and moves the tail pointer. </p>

</div>
</div>
<a class="anchor" id="a35f9a507905ad794d320040437ccca25"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ringbuffer_resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structringbuffer__t.html">ringbuffer_t</a> *&#160;</td>
          <td class="paramname"><em>rb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>new_capacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>resize the ring buffer (assign a new capacity). </p>
<p>This is done by allocating some new "entries" memory, copying over all existing pointers using <a class="el" href="ringbuffer_8c.html#a4d601184cd06125df9846aa6f04911d8" title="Retrieve the n-th entry (element pointer) from the ring buffer. ">ringbuffer_element()</a> and then replacing the old "entries" with the new pointers memory. "position" gets reset to 0. With sufficient new capacity the buffer count stays unchanged, otherwise an appropriate amount will be discarded ("pop"ping the oldest elements). </p>

</div>
</div>
<a class="anchor" id="a2687156335f978347ee27c76af75ce12"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* ringbuffer_tail </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structringbuffer__t.html">ringbuffer_t</a> *&#160;</td>
          <td class="paramname"><em>rb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>shortcut to retrieve "tail" element </p>
<dl class="section note"><dt>Note</dt><dd>non-destructive, i.e. this does <em>not</em> pop the element! </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ringbuffer_8c.html#af3a76d299009734662111e96abbd5e8b" title="discard the oldest entry (&quot;tail&quot; element) from the buffer. ">ringbuffer_pop</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jul 4 2016 12:36:31 for Lucciefr by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
